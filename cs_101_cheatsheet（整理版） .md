# CS101 Cheatsheetï¼ˆç´§å‡‘æ•´ç†ç‰ˆï¼‰

å£°æ˜ï¼šæ­¤cheetsheetå…¨éƒ¨å†…å®¹å‡ç”±chatgptç”Ÿæˆï¼Œæˆ‘æœ¬äººåªæä¾›promptå¹¶åˆ æ”¹

> æœ¬æ–‡æ¡£é¢å‘ **ç®—æ³• / æ•°æ®ç»“æ„ / Python ç«èµ›ä¸é¢è¯•**ï¼Œç›®æ ‡æ˜¯ï¼š **ä¸€çœ¼å®šä½é—®é¢˜ç±»å‹ â†’ å¥—æ¨¡æ¿ â†’ ä¸è¸©å¤æ‚åº¦å‘**ã€‚

---

## ç›®å½•

1. Python æ ¸å¿ƒæ•°æ®ç»“æ„å¤æ‚åº¦é€ŸæŸ¥
2. å¸¸è§ç®—æ³•æ€æƒ³æ€»è§ˆ
3. åŒºé—´é—®é¢˜æ¨¡æ¿
4. èƒŒåŒ…é—®é¢˜å…¨é›†
5. å•è°ƒæ ˆï¼ˆå¿…èƒŒï¼‰
6. æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰
7. DFS æœç´¢ä¸å›æº¯
8. BFS å¹¿åº¦ä¼˜å…ˆæœç´¢
9. æ»‘åŠ¨çª—å£ï¼ˆåŒæŒ‡é’ˆï¼‰
10. Python å¸¸ç”¨åº“é€ŸæŸ¥ä¸æ€§èƒ½æ³¨æ„äº‹é¡¹
11. ç®—æ³•é¢˜å‹é€ŸæŸ¥å¯¹ç…§è¡¨

---

## ä¸€ã€Python æ ¸å¿ƒæ•°æ®ç»“æ„å¤æ‚åº¦é€ŸæŸ¥

### 1. listï¼ˆåŠ¨æ€æ•°ç»„ï¼‰

- **ä¼˜åŠ¿**ï¼šéšæœºè®¿é—®å¿«
- **åŠ£åŠ¿**ï¼šä¸­é—´æ’åˆ æ…¢

| æ“ä½œ              | æ—¶é—´å¤æ‚åº¦      | è¯´æ˜   |
| --------------- | ---------- | ---- |
| a[i]            | O(1)       | éšæœºè®¿é—® |
| append / pop()  | O(1)       | å°¾éƒ¨æ“ä½œ |
| insert / pop(i) | O(n)       | æ•´ä½“ç§»åŠ¨ |
| x in a          | O(n)       | çº¿æ€§æŸ¥æ‰¾ |
| sort()          | O(n log n) | ç¨³å®šæ’åº |
| åˆ‡ç‰‡              | O(k)       | ä¼šæ‹·è´  |

âš ï¸ å‘ï¼š**ä¸è¦ç”¨ list å½“é˜Ÿåˆ—**

---

### 2. tupleï¼ˆä¸å¯å˜æ•°ç»„ï¼‰

- æ›´çœç©ºé—´
- å¯ä½œä¸º dict / set çš„ key

| æ“ä½œ     | æ—¶é—´   |
| ------ | ---- |
| t[i]   | O(1) |
| x in t | O(n) |

---

### 3. dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰

| æ“ä½œ                   | æ—¶é—´   | è¯´æ˜ |
| -------------------- | ---- | -- |
| append / pop         | O(1) |    |
| appendleft / popleft | O(1) |    |
| éšæœºè®¿é—®                 | O(n) | âŒ  |

é€‚ç”¨ï¼š**BFSã€æ»‘åŠ¨çª—å£**

---

### 4. dict / setï¼ˆå“ˆå¸Œï¼‰

| æ“ä½œ      | æ—¶é—´     | è¯´æ˜  |
| ------- | ------ | --- |
| æŸ¥æ‰¾ / æ’å…¥ | O(1)   | å‡æ‘Š  |
| éå†      | O(n)   |     |
| åˆå¹¶      | O(n+m) | æ–°å¯¹è±¡ |

âš ï¸ key å¿…é¡»å¯å“ˆå¸Œ

---

## äºŒã€å¸¸è§ç®—æ³•æ€æƒ³æ€»è§ˆ

| æ€æƒ³  | å…³é”®è¯     | å¸¸è§é¢˜ç›®    |
| --- | ------- | ------- |
| è´ªå¿ƒ  | æœ€å°‘ / æœ€å¤š | åŒºé—´è°ƒåº¦    |
| äºŒåˆ†  | æœ€å°æœ€å¤§    | ç­”æ¡ˆäºŒåˆ†    |
| å‰ç¼€å’Œ | å¤šæ¬¡åŒºé—´    | åŒºé—´å’Œ     |
| å·®åˆ†  | åŒºé—´ä¿®æ”¹    | åŒºé—´åŠ      |
| DFS | æ‰€æœ‰æ–¹æ¡ˆ    | æ’åˆ— / è·¯å¾„ |
| BFS | æœ€çŸ­æ­¥æ•°    | è¿·å®«      |
| DP  | æœ€ä¼˜å­ç»“æ„   | èƒŒåŒ…      |
| å•è°ƒæ ˆ | å·¦å³æœ€è¿‘    | çŸ©å½¢é¢ç§¯    |

---

## ä¸‰ã€åŒºé—´é—®é¢˜æ¨¡æ¿

### 1ï¸âƒ£ åŒºé—´è¦†ç›–ï¼ˆæœ€å°‘åŒºé—´ï¼‰

```python
# ç”¨æœ€å°‘çš„åŒºé—´è¦†ç›–ç›®æ ‡åŒºé—´ [L, R]
def min_cover(intervals, L, R):
    # æŒ‰åŒºé—´å·¦ç«¯ç‚¹æ’åº
    intervals.sort()
    cur = L        # å½“å‰å·²è¦†ç›–åˆ°çš„ä½ç½®
    i = 0          # åŒºé—´æŒ‡é’ˆ
    ans = 0        # ä½¿ç”¨çš„åŒºé—´æ•°é‡

    # åªè¦è¿˜æ²¡è¦†ç›–åˆ° R å°±ç»§ç»­
    while cur < R:
        far = cur  # åœ¨å½“å‰å¯é€‰åŒºé—´ä¸­èƒ½å»¶ä¼¸åˆ°çš„æœ€è¿œå³ç«¯
        # æ‰€æœ‰å·¦ç«¯ç‚¹ <= cur çš„åŒºé—´éƒ½æ˜¯â€œå¯é€‰åŒºé—´"
        while i < len(intervals) and intervals[i][0] <= cur:
            far = max(far, intervals[i][1])
            i += 1
        # å¦‚æœä¸€æ­¥éƒ½æ— æ³•å‘å³æ¨è¿›ï¼Œè¯´æ˜æ— è§£
        if far == cur:
            return -1
        # é€‰æ‹©èƒ½å»¶ä¼¸æœ€è¿œçš„åŒºé—´
        cur = far
        ans += 1
    return ans
```

---

### 2ï¸âƒ£ åŒºé—´åˆå¹¶

```python
# åˆå¹¶æ‰€æœ‰æœ‰é‡å çš„åŒºé—´
def merge_intervals(intervals):
    # å…ˆæŒ‰å·¦ç«¯ç‚¹æ’åº
    intervals.sort()
    res = []
    for l, r in intervals:
        # å¦‚æœå½“å‰åŒºé—´ä¸ç»“æœä¸­æœ€åä¸€ä¸ªåŒºé—´ä¸é‡å 
        if not res or l > res[-1][1]:
            res.append([l, r])
        else:
            # å¦åˆ™åˆå¹¶åŒºé—´ï¼Œæ›´æ–°å³ç«¯ç‚¹
            res[-1][1] = max(res[-1][1], r)
    return res
```

---

## å››ã€èƒŒåŒ…é—®é¢˜å…¨é›†ï¼ˆå¿…è€ƒï¼‰

### 1ï¸âƒ£ 0-1 èƒŒåŒ…

```python
# 0-1 èƒŒåŒ…ï¼šæ¯ä¸ªç‰©å“åªèƒ½é€‰ä¸€æ¬¡
def knapsack_01(weights, values, W):
    # dp[c] è¡¨ç¤ºå®¹é‡ä¸º c æ—¶çš„æœ€å¤§ä»·å€¼
    dp = [0] * (W + 1)

    for w, v in zip(weights, values):
        # å®¹é‡å¿…é¡»å€’åºéå†ï¼Œé˜²æ­¢åŒä¸€ç‰©å“è¢«é‡å¤ä½¿ç”¨
        for cap in range(W, w - 1, -1):
            # é€‰ or ä¸é€‰ å½“å‰ç‰©å“
            dp[cap] = max(dp[cap], dp[cap - w] + v)
    return dp[W]
```

å£è¯€ï¼š**0-1 â†’ å®¹é‡å€’åº**

---

### 2ï¸âƒ£ å®Œå…¨èƒŒåŒ…

```python
# å®Œå…¨èƒŒåŒ…ï¼šæ¯ä¸ªç‰©å“å¯ä»¥æ— é™æ¬¡ä½¿ç”¨
def knapsack_complete(weights, values, W):
    dp = [0] * (W + 1)

    for w, v in zip(weights, values):
        # å®¹é‡æ­£åºéå†ï¼Œå…è®¸é‡å¤é€‰å½“å‰ç‰©å“
        for cap in range(w, W + 1):
            dp[cap] = max(dp[cap], dp[cap - w] + v)
    return dp[W]
```

å£è¯€ï¼š**å®Œå…¨ â†’ å®¹é‡æ­£åº**

---

### 3ï¸âƒ£ å¤šé‡èƒŒåŒ…ï¼ˆäºŒè¿›åˆ¶ä¼˜åŒ–ï¼‰

**é—®é¢˜æè¿°**ï¼š æ¯ç§ç‰©å“æœ‰æ•°é‡é™åˆ¶ `cnt[i]`ï¼Œé‡é‡ `w[i]`ï¼Œä»·å€¼ `v[i]`ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š æŠŠ `cnt` æ‹†æˆè‹¥å¹²ä¸ª `1, 2, 4, ...` çš„å¹‚æ¬¡ä¹‹å’Œï¼Œ è½¬åŒ–ä¸ºè‹¥å¹²ä¸ª **0-1 èƒŒåŒ…ç‰©å“**ã€‚

```python
# å¤šé‡èƒŒåŒ…ï¼šäºŒè¿›åˆ¶æ‹†åˆ†ä¼˜åŒ–
def knapsack_multiple(weights, values, counts, W):
    dp = [0] * (W + 1)

    for w, v, c in zip(weights, values, counts):
        k = 1
        while c > 0:
            num = min(k, c)
            ww = w * num
            vv = v * num
            # å½“æˆ 0-1 èƒŒåŒ…ç‰©å“å¤„ç†
            for cap in range(W, ww - 1, -1):
                dp[cap] = max(dp[cap], dp[cap - ww] + vv)
            c -= num
            k <<= 1
    return dp[W]
```

ğŸ‘‰ è¦ç‚¹ï¼š

- æ•°é‡ `c` æ‹†æˆ **log c ä¸ªç‰©å“**
- å¤šé‡èƒŒåŒ… â†’ 0-1 èƒŒåŒ…

å£è¯€ï¼š**â€œå¤šé‡æ‹†äºŒè¿›åˆ¶ï¼Œå†åš 0-1â€**

---

## äº”ã€å•è°ƒæ ˆï¼ˆç§’æ€åŒºé—´ç±»ï¼‰

### ç»å…¸ç”¨é€”

- ä¸‹ä¸€ä¸ªæ›´å¤§ / æ›´å°å…ƒç´ 
- æœ€å¤§çŸ©å½¢é¢ç§¯
- å­æ•°ç»„æœ€å€¼è´¡çŒ®

```python
# å¯¹æ¯ä¸ªå…ƒç´ ï¼Œæ‰¾åˆ°å³ä¾§ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„å…ƒç´ 
def next_greater(a):
    n = len(a)
    res = [-1] * n     # é»˜è®¤ä¸å­˜åœ¨æ›´å¤§å…ƒç´ 
    st = []            # å•è°ƒé€’å‡æ ˆï¼Œå­˜ä¸‹æ ‡

    for i, x in enumerate(a):
        # å½“å‰å…ƒç´ æ¯”æ ˆé¡¶å¤§ï¼Œè¯´æ˜å®ƒæ˜¯æ ˆé¡¶å…ƒç´ çš„ next greater
        while st and a[st[-1]] < x:
            res[st.pop()] = x
        st.append(i)
    return res
```

---

### å…¸å‹ä¾‹é¢˜ï¼šç››æ°´å®¹å™¨ï¼ˆæ¥é›¨æ°´ï¼‰

**é—®é¢˜æè¿°**ï¼š ç»™å®šæŸ±çŠ¶å›¾é«˜åº¦ï¼Œè®¡ç®—å¯ä»¥æ¥å¤šå°‘é›¨æ°´ï¼ˆLeetCode 42ï¼‰ã€‚

```python
# å•è°ƒæ ˆè§£æ³•ï¼šè®¡ç®—æ¥é›¨æ°´æ€»é‡
def trap(height):
    st = []        # å­˜ä¸‹æ ‡ï¼Œä¿æŒé€’å‡
    water = 0

    for i, h in enumerate(height):
        # å½“å‰æŸ±å­æ›´é«˜ï¼Œå¯ä»¥å½¢æˆå‡¹æ§½
        while st and height[st[-1]] < h:
            mid = st.pop()     # å‡¹æ§½åº•éƒ¨
            if not st:
                break
            left = st[-1]     # å·¦è¾¹ç•Œ
            # å®½åº¦ * é«˜åº¦
            w = i - left - 1
            hgt = min(height[left], h) - height[mid]
            water += w * hgt
        st.append(i)
    return water
```

ğŸ‘‰ è¦ç‚¹ï¼š

- æ ˆç»´æŠ¤ **é€’å‡é«˜åº¦**
- æ¯æ¬¡å¼¹å‡ºè®¡ç®—ä¸€ä¸ªâ€œå‡¹æ§½â€

å£è¯€ï¼š**â€œå¼¹ä¸­ç®—æ°´ï¼Œå·¦å³å®šé«˜â€**

---

## å…­ã€æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰

```python
from bisect import bisect_left

# O(n log n) æ±‚æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦
def length_of_LIS(nums):
    tails = []
    # tails[k] = é•¿åº¦ä¸º k+1 çš„ä¸Šå‡å­åºåˆ—çš„æœ€å°ç»“å°¾
    for x in nums:
        # æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= x çš„ä½ç½®
        i = bisect_left(tails, x)
        if i == len(tails):
            # x æ¯”æ‰€æœ‰ç»“å°¾éƒ½å¤§ï¼Œå¯ä»¥ç›´æ¥æ¥åœ¨åé¢
            tails.append(x)
        else:
            # ç”¨æ›´å°çš„ç»“å°¾æ›¿æ¢ï¼Œæ–¹ä¾¿åç»­å»¶ä¼¸
            tails[i] = x
    return len(tails)
```

ä¸€å¥è¯ï¼š**ç»´æŠ¤ç»“å°¾æœ€å°å€¼**

---

## ä¸ƒã€DFS æœç´¢ä¸å›æº¯

### æ¨¡æ¿

```python
# DFS é€šç”¨æ¨¡æ¿ï¼ˆå›æº¯æ€æƒ³ï¼‰
def dfs(state):
    # ç»ˆæ­¢æ¡ä»¶ï¼šå½“å‰çŠ¶æ€å·²ç»æ˜¯ä¸€ä¸ªè§£
    if ç»ˆæ­¢æ¡ä»¶:
        return

    # æšä¸¾å½“å‰çŠ¶æ€ä¸‹çš„æ‰€æœ‰é€‰æ‹©
    for choice in choices:
        # 1. åšé€‰æ‹©ï¼ˆä¿®æ”¹çŠ¶æ€ï¼‰
        åšé€‰æ‹©
        # 2. é€’å½’è¿›å…¥ä¸‹ä¸€å±‚
        dfs(new_state)
        # 3. æ’¤é”€é€‰æ‹©ï¼ˆå›æº¯ï¼‰
        æ’¤é”€é€‰æ‹©
```

é€‚ç”¨ï¼šå…¨æ’åˆ—ã€å­é›†ã€è·¯å¾„ã€è¿é€šå—

---

### å…¸å‹ä¾‹é¢˜ 1ï¸âƒ£ï¼šé©¬èµ°æ—¥ï¼ˆKnight Tour è®¡æ•° / å¯è¾¾æ€§ï¼‰

**é—®é¢˜æè¿°**ï¼š æ£‹ç›˜ä¸Šé©¬ä»èµ·ç‚¹å‡ºå‘ï¼Œæ¯ä¸€æ­¥èµ°â€œæ—¥â€å­—ï¼Œé—®æ˜¯å¦èƒ½èµ°åˆ°ç»ˆç‚¹ / ä¸€å…±å¤šå°‘ç§èµ°æ³•ï¼ˆä¸é‡å¤æ ¼å­ï¼‰ã€‚

```python
# åˆ¤æ–­é©¬æ˜¯å¦èƒ½ä» (sx, sy) èµ°åˆ° (tx, ty)
# n x m æ£‹ç›˜ï¼Œä¸å…è®¸é‡å¤è®¿é—®æ ¼å­

dirs = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

visited = [[False]*m for _ in range(n)]
found = False

def dfs(x, y):
    global found
    if found:
        return
    # åˆ°è¾¾ç›®æ ‡
    if (x, y) == (tx, ty):
        found = True
        return
    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        # è¾¹ç•Œ + æœªè®¿é—®
        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
            visited[nx][ny] = True
            dfs(nx, ny)
            visited[nx][ny] = False
```

ğŸ‘‰ è¦ç‚¹ï¼š**æ–¹å‘æ•°ç»„ + visited + å›æº¯**

---

### å…¸å‹ä¾‹é¢˜ 2ï¸âƒ£ï¼šå…«çš‡åï¼ˆN çš‡åï¼‰

**é—®é¢˜æè¿°**ï¼š åœ¨ nÃ—n æ£‹ç›˜ä¸Šæ”¾ n ä¸ªçš‡åï¼Œä½¿ä»»æ„ä¸¤ä¸ªçš‡åä¸åŒè¡Œã€ä¸åŒåˆ—ã€ä¸åŒå¯¹è§’çº¿ã€‚

```python
# è¿”å› N çš‡åçš„è§£çš„æ•°é‡

def solveNQueens(n):
    col = [False] * n          # åˆ—æ˜¯å¦è¢«å 
    diag1 = [False] * (2*n)    # ä¸»å¯¹è§’çº¿ (row + col)
    diag2 = [False] * (2*n)    # å‰¯å¯¹è§’çº¿ (row - col + n)
    ans = 0

    def dfs(r):
        nonlocal ans
        # æˆåŠŸæ”¾å®Œ n è¡Œ
        if r == n:
            ans += 1
            return
        for c in range(n):
            if not col[c] and not diag1[r+c] and not diag2[r-c+n]:
                col[c] = diag1[r+c] = diag2[r-c+n] = True
                dfs(r + 1)
                col[c] = diag1[r+c] = diag2[r-c+n] = False

    dfs(0)
    return ans
```

ğŸ‘‰ è¦ç‚¹ï¼š

- **ä¸€è¡Œä¸€è¡Œæ”¾**ï¼ˆå¤©ç„¶é¿å…åŒè¡Œå†²çªï¼‰
- åˆ— / å¯¹è§’çº¿ç”¨å¸ƒå°”æ•°ç»„ O(1) åˆ¤æ–­

å£è¯€ï¼š**â€œè¡Œé€’å½’ï¼Œåˆ—æšä¸¾ï¼Œä¸‰æ•°ç»„åˆ¤å†²çªâ€**

---

### å…«çš‡åè¡¥å……åšæ³•ï¼šæŒ‰åˆ—å›æº¯ï¼ˆç­‰ä»·å†™æ³•ï¼‰

```python
# æŒ‰â€œåˆ—â€é€’å½’æ”¾çš‡åï¼ˆä¸æŒ‰è¡Œå®Œå…¨å¯¹ç§°ï¼‰
def solveNQueens_col(n):
    row = [False] * n
    diag1 = [False] * (2*n)    # r + c
    diag2 = [False] * (2*n)    # r - c + n
    ans = 0

    def dfs(c):
        nonlocal ans
        if c == n:
            ans += 1
            return
        for r in range(n):
            if not row[r] and not diag1[r+c] and not diag2[r-c+n]:
                row[r] = diag1[r+c] = diag2[r-c+n] = True
                dfs(c + 1)
                row[r] = diag1[r+c] = diag2[r-c+n] = False

    dfs(0)
    return ans
```

ğŸ‘‰ ç†è§£è¦ç‚¹ï¼š

- **è¡Œå›æº¯ / åˆ—å›æº¯å®Œå…¨å¯¹ç§°**
- é€‰â€œè¡Œ or åˆ—â€åªæ˜¯çŠ¶æ€å®šä¹‰ä¸åŒ

å£è¯€ï¼š**â€œå®šä¸€ç»´ï¼Œæšä¸¾å¦ä¸€ç»´â€**

---

### å…¸å‹ä¾‹é¢˜ 3ï¸âƒ£ï¼šå…¨æ’åˆ—ï¼ˆå«å»é‡ï¼‰

**é—®é¢˜æè¿°**ï¼š ç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œè¾“å‡ºæ‰€æœ‰å¯èƒ½çš„æ’åˆ—ï¼ˆå…ƒç´ å¯èƒ½é‡å¤ï¼‰ã€‚

```python
# è¿”å› nums çš„æ‰€æœ‰å…¨æ’åˆ—ï¼ˆå»é‡ï¼‰
def permute_unique(nums):
    nums.sort()              # æ’åºï¼Œæ–¹ä¾¿å»é‡
    used = [False] * len(nums)
    res = []
    path = []

    def dfs():
        # å½“å‰æ’åˆ—é•¿åº¦ç­‰äº nï¼Œè®°å½•ç­”æ¡ˆ
        if len(path) == len(nums):
            res.append(path[:])
            return
        for i in range(len(nums)):
            # å·²ä½¿ç”¨è¿‡çš„å…ƒç´ ä¸èƒ½å†ç”¨
            if used[i]:
                continue
            # å»é‡ï¼šç›¸åŒæ•°å­—ï¼Œå¿…é¡»æŒ‰é¡ºåºä½¿ç”¨
            if i > 0 and nums[i] == nums[i-1] and not used[i-1]:
                continue
            used[i] = True
            path.append(nums[i])
            dfs()
            path.pop()
            used[i] = False

    dfs()
    return res
```

ğŸ‘‰ è¦ç‚¹ï¼š

- `used` æ§åˆ¶æ˜¯å¦é€‰è¿‡
- **æ’åº + ç›¸é‚»å‰ªæ** å®ç°å»é‡

å£è¯€ï¼š**â€œæ’å¥½åºï¼Œç”¨æ•°ç»„ï¼Œå‰æ²¡ç”¨å°±è·³è¿‡â€**

---

## å…«ã€BFS å¹¿åº¦ä¼˜å…ˆæœç´¢

```python
from collections import deque

# BFS æ¨¡æ¿ï¼šæ±‚æœ€çŸ­æ­¥æ•°ï¼ˆæ— æƒå›¾ï¼‰
def bfs(start):
    q = deque([start])
    visited = {start}   # é˜²æ­¢é‡å¤è®¿é—®
    step = 0            # å½“å‰å±‚æ•° / æ­¥æ•°

    while q:
        for _ in range(len(q)):
            cur = q.popleft()
            if cur == target:
                return step
            for nxt in neighbors(cur):
                if nxt not in visited:
                    visited.add(nxt)
                    q.append(nxt)
        step += 1
```

é€‚ç”¨ï¼š**æœ€çŸ­æ­¥æ•° / æ— æƒå›¾**

---

### å…¸å‹ä¾‹é¢˜ï¼šè¿·å®«æœ€çŸ­è·¯ï¼ˆBFSï¼‰

```python
from collections import deque

# grid: 0 å¯èµ°, 1 éšœç¢
def shortest_path(grid, sx, sy, tx, ty):
    n, m = len(grid), len(grid[0])
    q = deque([(sx, sy)])
    dist = [[-1]*m for _ in range(n)]
    dist[sx][sy] = 0
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]

    while q:
        x, y = q.popleft()
        if (x, y) == (tx, ty):
            return dist[x][y]
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m \
               and grid[nx][ny] == 0 and dist[nx][ny] == -1:
                dist[nx][ny] = dist[x][y] + 1
                q.append((nx, ny))
    return -1
```

å£è¯€ï¼š**â€œBFS ä¸€å±‚ä¸€å±‚èµ°ï¼Œç¬¬ä¸€æ¬¡åˆ°å°±æ˜¯æœ€çŸ­â€**

---

## ä¹ã€æ»‘åŠ¨çª—å£ï¼ˆåŒæŒ‡é’ˆï¼‰

### é€‚ç”¨åœºæ™¯

- è¿ç»­å­æ•°ç»„ / å­ä¸²
- æœ€çŸ­ / æœ€é•¿åŒºé—´
- çª—å£å†…æ»¡è¶³æŸç§æ¡ä»¶

### é€šç”¨æ¨¡æ¿

```python
l = 0
window = {}

for r in range(len(s)):
    window[s[r]] = window.get(s[r], 0) + 1
    while çª—å£ä¸åˆæ³•:
        window[s[l]] -= 1
        if window[s[l]] == 0:
            del window[s[l]]
        l += 1
    # æ­¤æ—¶çª—å£åˆæ³•
```

å£è¯€ï¼š**â€œå³æ‰©æ‰¾è§£ï¼Œå·¦ç¼©ä¿æ³•â€**

---

### å…¸å‹ä¾‹é¢˜ï¼šæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

```python
# æ»‘åŠ¨çª—å£ï¼šæœ€é•¿æ— é‡å¤å­ä¸²
def lengthOfLongestSubstring(s):
    cnt = {}
    l = 0
    ans = 0

    for r, ch in enumerate(s):
        cnt[ch] = cnt.get(ch, 0) + 1
        while cnt[ch] > 1:
            cnt[s[l]] -= 1
            l += 1
        ans = max(ans, r - l + 1)
    return ans
```

å£è¯€ï¼š**â€œé‡å¤å°±ç¼©ï¼Œåˆæ³•å°±ç®—â€**

---

## ä¹ã€Python å¸¸ç”¨åº“é€ŸæŸ¥ï¼ˆheapq / bisect / defaultdict / cmp\_to\_key / æ‹·è´ï¼‰

### 0ï¸âƒ£ cmp\_to\_keyï¼ˆè‡ªå®šä¹‰æ’åºè§„åˆ™ï¼‰

å½“å†…ç½® `key=` ä¸å¤Ÿç”¨æ—¶ï¼Œä½¿ç”¨æ¯”è¾ƒå‡½æ•°ã€‚

```python
from functools import cmp_to_key

# è¿”å›è´Ÿæ•°ï¼ša < bï¼Œè¿”å› 0ï¼šç›¸ç­‰ï¼Œè¿”å›æ­£æ•°ï¼ša > b
def cmp(a, b):
    if a[0] != b[0]:
        return a[0] - b[0]        # ç¬¬ä¸€å…³é”®å­—å‡åº
    return b[1] - a[1]            # ç¬¬äºŒå…³é”®å­—é™åº

arr.sort(key=cmp_to_key(cmp))
```

âš ï¸ æ³¨æ„ï¼š

- `cmp` **åªè¿”å›å¤§å°å…³ç³»**ï¼Œä¸è¿”å› True / False
- èƒ½ç”¨ `key` å°±åˆ«ç”¨ `cmp`ï¼ˆ`cmp` æ›´æ…¢ï¼‰

å…¸å‹åœºæ™¯ï¼š

- åŒºé—´é¢˜ï¼ˆå·¦ç«¯ç‚¹å‡åºï¼Œå³ç«¯ç‚¹é™åºï¼‰
- å¤šå…³é”®å­—ã€éç‹¬ç«‹æ’åºè§„åˆ™

å£è¯€ï¼š**â€œkey ä¸è¡Œï¼Œå†ä¸Š cmp\_to\_keyâ€**

---

### 1ï¸âƒ£ heapqï¼ˆä¼˜å…ˆé˜Ÿåˆ— / å°æ ¹å †ï¼‰

### 1ï¸âƒ£ heapqï¼ˆä¼˜å…ˆé˜Ÿåˆ— / å°æ ¹å †ï¼‰

**ç‰¹ç‚¹**ï¼š

- åªæ”¯æŒå°æ ¹å †
- ç»´æŠ¤â€œå½“å‰æœ€å° / æœ€å¤§çš„ k ä¸ªå…ƒç´ â€

```python
import heapq

h = []
heapq.heappush(h, 3)
heapq.heappush(h, 1)
heapq.heappush(h, 5)

x = heapq.heappop(h)   # å¼¹å‡ºæœ€å°å€¼ 1
```

å¸¸è§æŠ€å·§ï¼š

```python
# å¤§æ ¹å †ï¼šå–ç›¸åæ•°
heapq.heappush(h, -x)

# å–æœ€å°çš„ k ä¸ªå…ƒç´ 
heapq.nsmallest(k, nums)

# å–æœ€å¤§çš„ k ä¸ªå…ƒç´ 
heapq.nlargest(k, nums)
```

å…¸å‹åº”ç”¨ï¼š

- Top K é—®é¢˜
- åˆå¹¶ k ä¸ªæœ‰åºæ•°ç»„
- Dijkstraï¼ˆæœ€çŸ­è·¯ï¼‰

å£è¯€ï¼š**â€œheapq é»˜è®¤å°æ ¹å †ï¼Œå¤§æ ¹å–åæ•°â€**

---

### 2ï¸âƒ£ bisectï¼ˆäºŒåˆ†æ’å…¥ / æœ‰åºæ•°ç»„ï¼‰

```python
from bisect import bisect_left, bisect_right

a = [1, 3, 3, 5]

bisect_left(a, 3)   # 1ï¼ˆç¬¬ä¸€ä¸ª >= 3ï¼‰
bisect_right(a, 3)  # 3ï¼ˆç¬¬ä¸€ä¸ª > 3ï¼‰
```

å…¸å‹ç”¨æ³•ï¼š

```python
# ä¿æŒæ•°ç»„æœ‰åºæ’å…¥
from bisect import insort
insort(a, 4)
```

åº”ç”¨åœºæ™¯ï¼š

- LISï¼ˆæœ€é•¿ä¸Šå‡å­åºåˆ—ï¼‰
- æœ‰åºæ•°ç»„ä¸­æŸ¥åŒºé—´ / è®¡æ•°
- åŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ—

å£è¯€ï¼š**â€œleft æ‰¾ >=ï¼Œright æ‰¾ >â€**

---

### 3ï¸âƒ£ defaultdictï¼ˆè‡ªåŠ¨åˆå§‹åŒ–å­—å…¸ï¼‰

```python
from collections import defaultdict

d = defaultdict(int)      # é»˜è®¤ 0
d2 = defaultdict(list)    # é»˜è®¤ç©ºåˆ—è¡¨
```

ç¤ºä¾‹ï¼šç»Ÿè®¡é¢‘ç‡

```python
for x in nums:
    d[x] += 1
```

ç¤ºä¾‹ï¼šå»ºå›¾

```python
g = defaultdict(list)
for u, v in edges:
    g[u].append(v)
```

å¯¹æ¯”æ™®é€š dictï¼š

```python
# æ™®é€š dict éœ€è¦åˆ¤ç©º
if x not in d:
    d[x] = 0
```

å…¸å‹åº”ç”¨ï¼š

- è®¡æ•°
- é‚»æ¥è¡¨
- åˆ†ç»„ / å“ˆå¸Œæ˜ å°„

å£è¯€ï¼š**â€œdefaultdict = ä¸ç”¨åˆ¤ç©ºçš„ dictâ€**

---

## åã€Python æ€§èƒ½å‘ä¸æŠ€å·§è¡¥å……

### 1ï¸âƒ£ æ·±æ‹·è´ vs æµ…æ‹·è´ï¼ˆå¿…è¸©å‘ï¼‰

```python
import copy

a = [[1, 2], [3, 4]]
b = a[:]              # æµ…æ‹·è´ï¼ˆåªæ‹·è´æœ€å¤–å±‚ï¼‰
c = copy.deepcopy(a)  # æ·±æ‹·è´ï¼ˆå®Œå…¨ç‹¬ç«‹ï¼‰
```

âš ï¸ åŒºåˆ«ï¼š

- **æµ…æ‹·è´**ï¼šå†…éƒ¨å…ƒç´ ä»ç„¶å…±äº«
- **æ·±æ‹·è´**ï¼šå®Œå…¨ä¸å…±äº«

```python
a[0][0] = 99
print(b)  # ä¼šå˜
print(c)  # ä¸å˜
```

å¸¸è§å‘ä½ï¼š

- `path[:]` æ˜¯æµ…æ‹·è´ï¼ˆä½†å¯¹ä¸€ç»´åˆ—è¡¨é€šå¸¸å¤Ÿç”¨ï¼‰
- DFS ä¸­ä¿å­˜äºŒç»´çŠ¶æ€ â†’ å¿…é¡»æ·±æ‹·è´

å£è¯€ï¼š**â€œä¸€ç»´åˆ‡ç‰‡å¤Ÿç”¨ï¼Œå¤šç»´å¿…é¡» deepcopyâ€**

---

### 1ï¸âƒ£ ä¸å®šè¡Œè¾“å…¥ï¼ˆè¯»åˆ° EOFï¼‰

```python
import sys
for line in sys.stdin:
    line = line.strip()
    if not line:
        continue
    # å¤„ç†æ¯ä¸€è¡Œ
```

æˆ–ä¸€æ¬¡æ€§è¯»å–ï¼š

```python
import sys
data = sys.stdin.read().split()
```

é€‚ç”¨ï¼šOJ è¾“å…¥è¡Œæ•°ä¸å›ºå®š / æ–‡ä»¶è¾“å…¥

---

### 2ï¸âƒ£ ä¿ç•™å°æ•° / æµ®ç‚¹è¾“å‡º

```python
x = 3.1415926
print(f"{x:.2f}")   # 3.14
print("%.3f" % x)  # 3.142
```

âš ï¸ æ¯”è¾ƒæµ®ç‚¹æ•°æ—¶ç”¨è¯¯å·®ï¼š

```python
abs(a - b) < 1e-9
```

---

### 3ï¸âƒ£ æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ˆå¼ºçƒˆæ¨è f-stringï¼‰

```python
name = "Alice"
age = 18
print(f"{name} is {age} years old")
```

å¸¸ç”¨æ ¼å¼ï¼š

```python
f"{x:>5}"    # å³å¯¹é½
f"{x:<5}"    # å·¦å¯¹é½
f"{x:^5}"    # å±…ä¸­
f"{x:06d}"   # è¡¥é›¶
```

---

### 4ï¸âƒ£ å¿«é€Ÿè¾“å…¥ï¼ˆç«èµ›å¿…å¤‡ï¼‰

```python
import sys
input = sys.stdin.readline
```

---

### 5ï¸âƒ£ å¸¸ç”¨å°æŠ€å·§

```python
# äº¤æ¢å˜é‡
a, b = b, a

# æšä¸¾ä¸‹æ ‡å’Œå€¼
for i, x in enumerate(arr):
    pass

# è§£åŒ…
x, y = point
```

âŒ å¾ªç¯ä¸­å­—ç¬¦ä¸²æ‹¼æ¥

```python
s += 'a'  # æ…¢
```

âœ… æ­£ç¡®å†™æ³•

```python
''.join(chars)
```

---

## åä¸€ã€ç®—æ³•é¢˜å‹é€ŸæŸ¥è¡¨

| é¢˜ç›®ç‰¹å¾   | é¦–é€‰æ–¹æ³•    |
| ------ | ------- |
| æœ€çŸ­è·¯å¾„   | BFS     |
| æ‰€æœ‰æ–¹æ¡ˆ   | DFS     |
| åŒºé—´æœ€ä¼˜   | DP / è´ªå¿ƒ |
| å·¦å³æœ€è¿‘   | å•è°ƒæ ˆ     |
| å¤šæ¬¡åŒºé—´æŸ¥è¯¢ | å‰ç¼€å’Œ     |
| æœ€å°æœ€å¤§   | äºŒåˆ†ç­”æ¡ˆ    |

---

> å»ºè®®ç”¨æ³•ï¼š **åšé¢˜å‰ç¿»ç›®å½• â†’ å¯¹å·å…¥åº§ â†’ ç›´æ¥å¥—æ¨¡æ¿**

